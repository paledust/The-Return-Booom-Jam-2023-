// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel Main

#include "NMGGrassBladeComputeHelpers.hlsl"
#include "UnityCG.cginc"
//Vertex on source mesh
struct SourceVertex{
    float3 positionOS; //Position in object space
};
//vertex on generated mesh
struct DrawVertex{
    float3 positionWS; //Position in world space
    float height;
};
//Draw mesh triangle
struct DrawTriangle{
    float3 normalWS; //Normal in world space
    DrawVertex vertices[3];
};
struct IndirectArgs{
    uint numVerticesPerInstance;
    uint numInstances;
    uint startVertexIndex;
    uint startInstanceIndex;
};

RWStructuredBuffer<IndirectArgs> _IndirectArgsBuffer;
StructuredBuffer<SourceVertex> _SourceVertices;
StructuredBuffer<int> _SourceTriangles;
AppendStructuredBuffer<DrawTriangle> _DrawTriangles;

int _NumSourceTriangles;
float _PyramidHeight;
float4x4 _LocalToWorld;

void GetCenterAndBasis(SourceVertex a, SourceVertex b, SourceVertex c, out float3 positionWS, out float3 normalWS, out float3x3 TsToWs){
    float3 positionA_WS = mul(_LocalToWorld, float4(a.positionOS, 1)).xyz;
    float3 positionB_WS = mul(_LocalToWorld, float4(b.positionOS, 1)).xyz;
    float3 positionC_WS = mul(_LocalToWorld, float4(c.positionOS, 1)).xyz;

    positionWS = GetTriangleCenter(positionA_WS, positionB_WS, positionC_WS);
    GetTriangleNormalAndTSToWSMatrix(positionA_WS, positionB_WS, positionC_WS, normalWS, TsToWs);
}

DrawVertex SetupBladePoint(float3 anchorWS, float3x3 TsToWs, float2 uv){
    float3 offsetTS = float3(uv.x-0.5f, 0, uv.y);
    float3 offsetWS = mul(TsToWs, offsetTS);

    float3 positionWS = anchorWS + offsetWS;

    DrawVertex o = (DrawVertex)0;
    o.positionWS = positionWS;
    o.height = uv.y;
    return o;
}

[numthreads(256,1,1)]
void Main (uint3 id : SV_DispatchThreadID){
    if((int)id.x >= _NumSourceTriangles){
        return;
    } 

    int triStart = id.x * 3;

    float3 positionWS, normalWS;
    float3x3 TsToWs;
    GetCenterAndBasis(
        _SourceVertices[_SourceTriangles[triStart]],
        _SourceVertices[_SourceTriangles[triStart+1]],
        _SourceVertices[_SourceTriangles[triStart+2]],
        positionWS, normalWS, TsToWs);
    
    DrawVertex vertices[3];
    vertices[0] = SetupBladePoint(positionWS, TsToWs, float2(0,0));
    vertices[1] = SetupBladePoint(positionWS, TsToWs, float2(1,0));
    vertices[2] = SetupBladePoint(positionWS, TsToWs, float2(0.5,1));

    DrawTriangle tri = (DrawTriangle)0;
    tri.normalWS = normalWS;
    tri.vertices[0] = vertices[0];
    tri.vertices[1] = vertices[1];
    tri.vertices[2] = vertices[2];
    _DrawTriangles.Append(tri);

    InterlockedAdd(_IndirectArgsBuffer[0].numVerticesPerInstance, 3);
}